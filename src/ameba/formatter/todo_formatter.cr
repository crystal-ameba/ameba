module Ameba::Formatter
  # A formatter that creates a todo config.
  # Basically, it takes all issues reported and disables corresponding rules
  # or excludes failed sources from these rules.
  class TODOFormatter < DotFormatter
    @config_path : Path

    def initialize(@output = STDOUT, @config_path = Config::DEFAULT_PATH)
    end

    def finished(sources) : Nil
      super

      issues = sources.flat_map(&.issues)
      unless issues.any? { |issue| !issue.disabled? }
        @output.puts "No issues found. File is not generated."
        return
      end

      if issues.any?(&.syntax?)
        @output.puts "Unable to generate TODO file. Please fix syntax issues."
        return
      end

      issues.sort_by!(&.rule.name)
      generate_todo_config(issues)

      @output.puts "Created #{@config_path}"
    end

    private def generate_todo_config(issues) : Nil
      File.open(@config_path, mode: "w") do |file|
        file.puts header

        {% if compare_versions(Crystal::VERSION, "1.17.0") > 0 %}
          YAML::Builder.build(file) do |builder|
            builder.stream do
              builder.document(implicit_start_indicator: true) do
                build_yaml(file, builder, issues)
              end
            end
          end
        {% else %}
          # Before 1.17.0 we cannot prevent the document start indicator so
          # we must remove it explicitly (https://github.com/crystal-lang/crystal/pull/15835)
          yaml = String.build do |io|
            YAML.build(io) do |builder|
              build_yaml(io, builder, issues)
            end
          end
          file << yaml.lchop("---\n")
        {% end %}
      end
    end

    private def build_yaml(io, builder, issues)
      builder.mapping do
        rule_issues_map(issues).each do |rule, rule_issues|
          builder.flush
          io.puts

          rule_to_yaml(builder, rule, rule_issues)
        end
      end
    end

    private def rule_issues_map(issues)
      Hash(Rule::Base, Array(Issue)).new.tap do |hash|
        issues.each do |issue|
          next if issue.disabled? || issue.rule.is_a?(Rule::Lint::Syntax)
          next if issue.correctable? && config[:autocorrect]?

          (hash[issue.rule] ||= Array(Issue).new) << issue
        end
      end
    end

    private def header
      <<-HEADER
        # This configuration file was generated by `ameba --gen-config`
        # on #{Time.utc} using Ameba version #{VERSION}.
        # The point is for the user to remove these configuration records
        # one by one as the reported problems are removed from the code base.
        #
        # For more details on any individual rule, run `ameba --only RuleName`.

        Version: "#{VERSION}"

        HEADER
    end

    private def exclude_paths(issues)
      issues
        .compact_map(&.location.try &.filename.try &.to_s)
        .uniq!
        .map { |path| Path[path].to_posix.to_s }
    end

    private def rule_to_yaml(yaml, rule, issues)
      yaml.scalar rule.name
      yaml.mapping do
        yaml.scalar "Excluded"
        yaml.sequence do
          exclude_paths(issues).each do |path|
            yaml.scalar path
          end
        end
      end
    end
  end
end
